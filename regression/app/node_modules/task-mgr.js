
/**
 * Created with JetBrains WebStorm.
 * User: tafeng.dxx
 * Date: 12-11-24
 * Time: 下午3:45
 */

//导入模块
var EventManager = require('event-mgr');
var db = require('data-mod');


//数据获取周期
var INTERVAL = 30000;

/*用例队列*/
var TaskCache = {
        tasks:[],
        total:0
    };

/*报告缓冲区*/
var state = true;

/**
 * 用例管理函数，负责取用例，插入用例测试结果
 * @type {Object}
 */
var TaskManager = {
    init:function () {

	db.init('10.232.35.23', 'root', '1234');
        this._bindEvents();
        this.fetchTask();
        this.protectTask();
    },
    /*用例结束，插入数据库结果
     * 每满50个才进行一次性的插入，防止频繁的操作数据库
	 *
	 *	修改: 每满50操作一次, 如果是多条语句, 反而提高了数据库的Qps, 不如分散操作
	 *			而且, 如果服务器DOWN机, 会造成数据丢失
	 *			所以, 这里修改了   by daolin
	 *
	 *	每条报告, 立即插入一次
     */
    report:function (task) {

        console.log("report task id", task.id)

        db.updateOne(task, function(){
            --TaskCache.total == 0 && TaskManager.fetchTask();
        });

    },
    //守护函数，防止在无浏览器而又有任务的情况下，进程僵化
    protectTask:function () {
        setInterval(function () {
            if (TaskCache.total && !TaskManager.browserCache.total) {
                console.log("data-update")
                EventManager.emit('task:data_update');
            }
            else{
                TaskManager.fetchTask();
            }
        }, INTERVAL)
    },
    fetchTask:function () {

        db.findLatestSpecs(function (data) {
            if (!data.length) {
                console.log('no data');
                return setTimeout(TaskManager.fetchTask, INTERVAL);
            }

            TaskCache.tasks = data;
            TaskCache.total = data.length;
            this.browserCache = {};
            for(var i = 0;i<data.length;i++){
                console.log("get task", data[i].id)
            }
            EventManager.emit('task:data_update');
        });
    },
    browserCache:{total:0},
    _eventsMap:{
        /*更新浏览器*/
        'client:types':function (types, clients) {
            if(state == false) return;

            var i, len = types.length, tasks = TaskCache.tasks;
            TaskManager.browserCache.total = len;
            //对每种浏览器复制一份用例引用
            for (i = len - 1; i > -1; --i) {
                TaskManager.browserCache[types[i]] = TaskCache.tasks.slice(0);
            }
            //对每个用例，将计数器至为浏览器类型数量
            for (i = 0, total = TaskCache.total; i < total; ++i) {
                tasks[i].browserCount = tasks[i].total_specs = len;
            }
        },
        /*浏览器空闲事件，触发task事件，同时丢入一个task*/
        'task:pause':function (clientType) {
            state = false
        },
        /*浏览器空闲事件，触发task事件，同时丢入一个task*/
        'task:restart':function (clientType) {
            state = true
        },

        /*浏览器空闲事件，触发task事件，同时丢入一个task*/
        'client:available':function (clientType) {
            if(state == false) return;

            var tasks = TaskManager.browserCache[clientType];

            if (tasks && tasks.length) {

                var task =  tasks.shift();


                EventManager.emit('client:task_start', task, clientType);
                //task && clientObject.runTask(task)
            }
        },
        //运行一半，某类浏览器特吗的没了。。
        'client:resettype':function (type) {
            console.info('[ClientMgr Event] client:resettype', type);
            var typeTask = TaskManager.browserCache[type];

            if (!typeTask) { return; }

            for (var i = 0, len = typeTask.length; i < len; ++i) {
                typeTask[i].reportData = 'disconnect';
                EventManager.emit('client:task_finish', typeTask[i]);
            }
            //清空该类型
            delete TaskManager.browserCache[type];
            --TaskManager.browserCache.total;

        },
        /*用例测完*/
        'client:task_finish':function (task) {
            //用例测完，减少计数器

            if (--task.browserCount == 0) {

                //计数器为0，减少用例池的总数，同时报告该用例结果
                TaskManager.report(task);


            }
        }
    },
    //事件绑定
    _bindEvents:function () {
        var evts = this._eventsMap;
        for (var k in evts) {
            EventManager.on(k, evts[k]);
        }
    }
};

exports.TaskManager = TaskManager;
