/**
 * Created with JetBrains WebStorm.
 * User: tafeng.dxx
 * Date: 12-11-24
 * Time: 下午3:45
 */

//导入模块
var EventManager = require('event-mgr');
var db = require('data-mod');

//数据获取周期
var INTERVAL = 60000;

/*用例队列*/
var TaskCache = {
    tasks:[]
};


/**
 * 用例管理函数，负责取用例，插入用例测试结果
 * @type {Object}
 */
var TaskManager = {
    init:function (ClientManager) {
        this.ClientManager = ClientManager;
        db.init('10.232.35.23', 'root', '1234');
        this.observeClientAvailable();
        this.fetchTask();
        this.protectTask();

    },

    getNextTaskByClientType:function (clientType) {
        for (var i = 0; i < TaskCache.tasks.length; i++) {

            var result = TaskCache.tasks[i]._task_result;

            if (!result || !result[clientType]) {
                return TaskCache.tasks[i];
            }
        }
    },

    isTaskComplete:function (task) {
        var types = this.ClientManager.getTypes();
        var result = task._task_result || {};
        var isOK = true;
        for (var i = 0; i < types.length; i++) {
            if (!result[types[i]] || !result[types[i]].reports) {
                isOK = false;
                break;
            }
        }
        return isOK;

    },
    /*用例结束，插入数据库结果
     * 每满50个才进行一次性的插入，防止频繁的操作数据库
     *
     *	修改: 每满50操作一次, 如果是多条语句, 反而提高了数据库的Qps, 不如分散操作
     *			而且, 如果服务器DOWN机, 会造成数据丢失
     *			所以, 这里修改了   by daolin
     *
     *	每条报告, 立即插入一次
     */
    report:function (task) {
        var host = this;
        host.removeTask(task);
        host.mixReport(task)


        db.updateOne(task, function () {

            if (TaskCache.tasks.length == 0) {
                TaskManager.fetchTask();
            }
        });

    },
    addTask:function (tasks) {
        console.log("add")
        for(var i =0;i<tasks.length;i++){
            var isExist = false;
            for(var j=0;j<TaskCache.tasks.length;j++){
                if(TaskCache.tasks[j].id == tasks[i].id){
                    isExist=true;
                    break
                }
            }
            if(!isExist) TaskCache.tasks.push(tasks[i])
        }

    },
    removeTask:function (task) {
        for (var i = 0; i < TaskCache.tasks.length; i++) {

            if (TaskCache.tasks[i].id == task.id) {
                //回归任务kaishi

                TaskCache.tasks.splice(i, 1);
                break;
            }
        }
    },
    clearTask:function () {
        console.log("clear task")
        var host = this;
        var types = this.ClientManager.getTypes();
        var haveType = function (type) {
            for (var i = 0; i < types.length; i++) {
                if (types[i] == type)return true;
            }
        }
        if (TaskCache.tasks.length != 0) {

            for (var i = 0; i < TaskCache.tasks.length; i++) {
                //清理无效结果
                var results = TaskCache.tasks[i]._task_result||{};
                for (var p in results) {
                    if (!haveType[p]) {
                        delete  results[p];
                    }
                }
                // 结果已经完成的结果
                if (host.isTaskComplete(TaskCache.tasks[i])) {

                    host.report(TaskCache.tasks[i])
                }
            }
        }
    },
    mixReport:function (task) {
        if (!task._task_result)return;
        if (!task.task_result)task.task_result = {}
        if (typeof task.task_result == "string") {
            task.task_result = JSON.parse(task.task_result);
        }

        for (var p in task._task_result) {
            task.task_result[p] = task._task_result[p];
        }


    },
    //守护函数，防止在无浏览器而又有任务的情况下，进程僵化
    protectTask:function () {
        var host = this;
        setInterval(function () {
            if (TaskCache.tasks.length) {
                host.clearTask();
            }
            if (TaskCache.tasks.length) {
                host.ClientManager.start();
            }
            if (TaskCache.tasks.length <= 20) {
                console.log("小于20个，补充新实例")
                TaskManager.fetchTask();
            }

        }, INTERVAL)
    },
    fetchTask:function () {
        var host = this;

        db.findLatestSpecs(function (data) {
            if (data && data.length) {
                host.addTask(data)

                if (TaskCache.tasks.length) {
                    host.ClientManager.start();
                }

            }

        });
    },

    //事件绑定
    observeClientAvailable:function () {
        var host = this;

        EventManager.on("client:available", function (client) {

            var type = client.clientType;

            console.log("---------"+type + " client:available-----------------");
            console.log("all type:",host.ClientManager.getTypes());
            console.log("all task:"+TaskCache.tasks.length)


            var task = TaskManager.getNextTaskByClientType(type);

            if (task) {
                console.log(task.id + " run in " + type)
                var time;
                var isComplete = false;
                if (!task._task_result) {
                    task._task_result = {}
                }
                task._task_result[type] = {};
                client.run(task,
                    function (data) {
                        if (data && data.reports) {
                            isComplete = true;
                            if (time) {
                                clearTimeout(time);
                                time = null;
                            }
                            task._task_result[type] = data;
                            console.log(task.id + " complete in " + type)

                            if (TaskManager.isTaskComplete(task)) {
                                console.log(task.id + " complete in all")
                                TaskManager.report(task);
                            }
                        }
                        else {
                            //准备重新运行
                            isComplete = true;
                            delete    task._task_result[type];

                        }


                    },
                    function () {
                        if (!isComplete) {
                            delete    task._task_result[type];
                            console.log(task.id + " 超时")
                        }

                    })


            }
        });
        EventManager.on("client:update", function () {
            if (TaskCache.tasks.length) {

                host.clearTask();
            }
        })

    }
};

module.exports = TaskManager;



